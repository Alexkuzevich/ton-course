
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;

// This is class that describes you smart contract.
contract task3_1 {

    string[] public queue;
    //string[] public tempArray;

    // Contract can have a `constructor` – function that will be called when contract will be deployed to the blockchain.
    // In this example constructor adds current time to the instance variable.
    // All contracts need call tvm.accept(); for succeeded deploy
    constructor() public {
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();
    }


	// Modifier that allows to accept some external messages
	modifier checkOwnerAndAccept {
		// Check that message was signed with contracts key.
		require(msg.pubkey() == tvm.pubkey(), 102);
		tvm.accept();
		_;
	}

    /*
    3.1. "Очередь в магазине"
    Хранилище данных - массив строк (Где строки имена людей, которые встают в очередь).
    Должны быть доступны опции:
    встать в очередь (переданное имя встает в конец очереди - в конец массива)
    вызвать следующего (первый из очереди уходит - нулевой элемент массива пропадает)
    */
    function getIn(string name) public checkOwnerAndAccept {
        
        queue.push(name);
    }

    function getOut() public checkOwnerAndAccept {

        string[] tempArray;
        uint range = queue.length;
        // реверс этого массива запишем во временный
        for (uint256 i = range; i > 0; i--){
            tempArray.push(queue[i - 1]);  
        }
        // теперь удаляем требуемый элемент
        // в данный момент это последний элемент временного массива, поэтому можно воспользоваться pop()
        tempArray.pop();
        uint tempRange = tempArray.length;
        // теперь реверсируем массив обратно в исходный (уже без удаленного элемента)
        for (uint256 i = tempRange; i > 0; i--){
            queue[tempRange - i] = tempArray[i - 1]; 
        }
        // удаляем лишний по количеству элемент (это костыль)
        queue.pop();
    }
}
